#include <iostream>
#include <stack>
using namespace std;

struct Point
{
    int x, y;
};

int orientation(Point p, Point q, Point r)
{
    int val = (q.y - p.y) * (r.x - q.x) -
    (q.x - p.x) * (r.y - q.y);

    if (val == 0) return 0;
    return (val > 0)? 1: 2;
}

int distance2(Point p1, Point p2)
{
    return (p1.x - p2.x)*(p1.x - p2.x) + (p1.y - p2.y)*(p1.y - p2.y);
}

Point p0;

int compare(Point a, Point b)
{
    int o = orientation(p0, a, b);
    if (o == 0)
    {
        return distance2(p0, a) < distance2(p0, b);
    }

    return o == 2;
}

void convexHull(Point a[], int n)
{
    int minIndex = 0;
    for (int i = 1; i < n; ++i)
    {
        if (a[i].y < a[minIndex].y || a[i].y == a[minIndex].y && a[i].x < a[minIndex].x)
        {
            minIndex = i;
        }
    }

    swap(a[0], a[minIndex]);

    p0 = a[0];
    sort(a + 1, a + n, compare);

    stack<int> s;
    s.push(0);
    s.push(1);

    int i = 2;
    while (i < n && !s.empty())
    {
        int t = s.top();
        s.pop();

        if (!s.empty() && orientation(a[s.top()], a[t], a[i]) == 2)
        {
            s.push(t);
            s.push(i);
            ++i;
        }
    }

    while (!s.empty())
    {
        printf("(%d, %d) ", a[s.top()].x, a[s.top()].y);
        s.pop();
    }
}

int main()
{
    Point points[] = {{0, 3}, {1, 1}, {2, 2}, {4, 4},
                      {0, 0}, {1, 2}, {3, 1}, {3, 3}};
    int n = sizeof(points)/sizeof(points[0]);

    convexHull(points, n);
}

/*

(0, 3) (4, 4) (3, 1) (0, 0)

*/
