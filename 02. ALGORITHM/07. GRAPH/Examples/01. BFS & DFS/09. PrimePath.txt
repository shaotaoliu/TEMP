#include <iostream>
#include <queue>
#include <bits/stdc++.h>
#include <map>
#include <stack>
using namespace std;

class Graph
{
    int V;
    list<int>* adj;

public:
    Graph(int V)
    {
        this->V = V;
        adj = new list<int>[V];
    }

    void addedge(int V1, int V2)
    {
        adj[V1].push_back(V2);
        adj[V2].push_back(V1);
    }

    int BFS(vector<int> &vec, int num1, int num2);
};

// Finding all 4-digit prime numbers
void findAllPrimes(vector<int> &v)
{
    bool a[10000];
    memset(a, true, sizeof(a));

    for (int i = 2; i * i <= 10000; ++i)
    {
        if (a[i])
        {
            for (int j = i * i; j < 10000; j += i)
            {
                a[j] = false;
            }
        }
    }

    for (int i = 1000; i < 10000; ++i)
    {
        if (a[i])
        {
            v.push_back(i);
        }
    }
}

// Returns true if a and b differ by a single digit.
bool diffBy1(int a, int b)
{
    string s1 = to_string(a);
    string s2 = to_string(b);
    int count = 0;

    for (int i = 0; i < 4; ++i)
    {
        if (s1[i] != s2[i])
        {
            ++count;
        }
    }

    return count == 1;
}

int Graph::BFS(vector<int> &vec, int num1, int num2)
{
    bool visited[vec.size()];
    memset(visited, false, sizeof(visited));

    queue<vector<int>> q;
    q.push({num1});
    visited[num1] = true;

    while (!q.empty())
    {
        vector<int> v = q.front();
        int u = v[v.size() - 1];
        q.pop();

        for (auto it = adj[u].begin(); it != adj[u].end(); ++it)
        {
            if (*it == num2)
            {
                for (int k : v)
                {
                    printf("%d -> ", vec[k]);
                }

                printf("%d\n", vec[num2]);
                return v.size();
            }
            else if (visited[*it] == false)
            {
                vector<int> v2(v);
                v2.push_back(*it);
                q.push(v2);
                visited[*it] = true;
            }
        }
    }

    return INT_MAX;
}

int shortestPath(int num1, int num2)
{
    vector<int> vec;
    findAllPrimes(vec);

    // generate the graph
    Graph g(vec.size());
    for (int i = 0; i < vec.size(); ++i)
    {
        for (int j = i+1; j < vec.size(); ++j)
        {
            if (diffBy1(vec[i], vec[j]))
            {
                g.addedge(i, j);
            }
        }
    }

    int first, second;
    for (int i = 0; i < vec.size(); ++i)
    {
        if (vec[i] == num1) first = i;
        if (vec[i] == num2) second = i;
    }

    return g.BFS(vec, first, second);
}

int main()
{
    int num1 = 1033, num2 = 8179;
    cout << shortestPath(num1, num2);
    return 0;
}

/*

1033 -> 1031 -> 1051 -> 1151 -> 1171 -> 8171 -> 8179
6

*/