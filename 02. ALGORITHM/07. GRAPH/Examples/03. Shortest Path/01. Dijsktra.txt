#include <iostream>
#include <queue>
#include <bits/stdc++.h>
#include <map>
#include <stack>
using namespace std;

class Graph
{
    int V;
    list<pair<int, int>> *adj;           // also vector is ok

public:
    Graph(int n)
    {
        V = n;
        adj = new list<pair<int, int>>[n];
    }

    void add_edge(int u, int v, int w)
    {
        adj[u].push_back(make_pair(v, w));
        adj[v].push_back(make_pair(u, w));
    }

    void shortestPath(int src);
};

int findMinDist(set<int> S, int dist[])
{
    int mindist = INT_MAX;
    int u;

    for (int i : S)
    {
        if (dist[i] < mindist)
        {
            mindist = dist[i];
            u = i;
        }
    }

    return u;
}

void Graph::shortestPath(int src)
{
    set<int> S;
    int dist[V];
    int path[V];

    for (int i = 0; i < V; ++i)
    {
        dist[i] = INT_MAX;
        path[i] = -1;
        S.insert(i);
    }

    dist[src] = 0;

    while (!S.empty())
    {
        int u = findMinDist(S, dist);
        S.erase(u);

        for (list<pair<int, int>>::iterator it = adj[u].begin(); it != adj[u].end(); ++it)
        {
            int sum = dist[u] + it->second;
            if (sum < dist[it->first])
            {
                dist[it->first] = sum;
                path[it->first] = u;
            }
        }
    }

    for (int i = 0; i < V; ++i)
    {
        printf("%d: %3d, %3d\n", i, dist[i], path[i]);
    }
}

int main()
{
    int n = 9;
    Graph g(n);

    g.add_edge(0, 1, 4);
    g.add_edge(0, 7, 8);
    g.add_edge(1, 2, 8);
    g.add_edge(1, 7, 11);
    g.add_edge(2, 3, 7);
    g.add_edge(2, 8, 2);
    g.add_edge(2, 5, 4);
    g.add_edge(3, 4, 9);
    g.add_edge(3, 5, 14);
    g.add_edge(4, 5, 10);
    g.add_edge(5, 6, 2);
    g.add_edge(6, 7, 1);
    g.add_edge(6, 8, 6);
    g.add_edge(7, 8, 7);

    g.shortestPath(0);
}

/*

0:   0,  -1
1:   4,   0
2:  12,   1
3:  19,   2
4:  21,   5
5:  11,   6
6:   9,   7
7:   8,   0
8:  14,   2

*/